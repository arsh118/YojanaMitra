// pages/api/kit.ts
import { NextApiRequest, NextApiResponse } from 'next'
import archiver from 'archiver'
import fs from 'fs'
import path from 'path'

interface FileInfo {
  url: string
  name: string
  type?: string
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  if (req.method !== 'POST') return res.status(405).json({ error: 'Method not allowed' })
  
  const { files, schemeTitle, userName } = req.body
  
  // Support both old format (filledUrl, docsUrl) and new format (files array)
  let filesToZip: FileInfo[] = []
  
  if (files && Array.isArray(files)) {
    // New format: array of file objects
    filesToZip = files
  } else if (req.body.filledUrl || req.body.docsUrl) {
    // Old format: backward compatibility
    filesToZip = []
    if (req.body.filledUrl) {
      filesToZip.push({ url: req.body.filledUrl, name: 'FilledForm.pdf' })
    }
    if (req.body.docsUrl) {
      filesToZip.push({ url: req.body.docsUrl, name: 'Documents.txt' })
    }
  } else {
    return res.status(400).json({ error: 'files array or filledUrl/docsUrl required' })
  }

  if (filesToZip.length === 0) {
    return res.status(400).json({ error: 'No files to include in kit' })
  }

  // Validate all files exist
  const filePaths: Array<{ path: string; name: string }> = []
  for (const fileInfo of filesToZip) {
    const filePath = path.join(process.cwd(), 'public', fileInfo.url.replace(/^\//, ''))
    if (!fs.existsSync(filePath)) {
      console.warn(`[kit] File not found: ${filePath}`)
      continue // Skip missing files instead of failing
    }
    filePaths.push({
      path: filePath,
      name: fileInfo.name || path.basename(fileInfo.url)
    })
  }

  if (filePaths.length === 0) {
    return res.status(404).json({ error: 'No valid files found' })
  }

  try {
    // Set headers for file download
    const kitName = schemeTitle 
      ? `${schemeTitle.replace(/[^a-z0-9]/gi, '_')}_ApplicationKit.zip`
      : userName
        ? `${userName.replace(/[^a-z0-9]/gi, '_')}_ApplicationKit.zip`
        : 'application-kit.zip'

    res.setHeader('Content-Type', 'application/zip')
    res.setHeader('Content-Disposition', `attachment; filename="${kitName}"`)

    // Create zip archive
    const archive = archiver('zip', {
      zlib: { level: 9 } // Maximum compression
    })

    // Handle errors
    archive.on('error', (err) => {
      console.error('[kit] Archive error:', err)
      if (!res.headersSent) {
        res.status(500).json({ error: 'Failed to create zip file' })
      }
    })

    // Pipe archive to response
    archive.pipe(res)

    // Add all files to archive
    for (const { path: filePath, name } of filePaths) {
      archive.file(filePath, { name })
      console.log(`[kit] Added file to archive: ${name}`)
    }

    // Create a README file with instructions
    const readmeContent = `Application Kit for ${schemeTitle || 'Government Scheme'}

Generated on: ${new Date().toLocaleString('en-IN')}
Applicant: ${userName || 'Not specified'}

This kit contains:
${filePaths.map((f, i) => `${i + 1}. ${f.name}`).join('\n')}

Instructions:
1. Review all documents carefully
2. Sign where required
3. Attach any missing documents mentioned in the checklist
4. Submit the application as per the scheme guidelines

For support, contact the scheme helpline or visit the official website.

---
Generated by YojanaMitra - Your AI Copilot for Government Schemes
`

    archive.append(readmeContent, { name: 'README.txt' })

    // Finalize the archive
    await archive.finalize()

    console.log(`[kit] Successfully created zip file: ${kitName} with ${filePaths.length} files`)
  } catch (err: any) {
    console.error('[kit] Error creating zip:', err)
    if (!res.headersSent) {
      return res.status(500).json({ error: err.message || 'Failed to create application kit' })
    }
  }
}

